# 01.1.1 命题逻辑 / Propositional Logic / Aussagenlogik / Logique propositionnelle

[返回上级](../README.md) | [返回全局导航](../../GLOBAL_NAVIGATION.md)

---

## 概述 / Overview

命题逻辑是形式逻辑的基础，研究命题之间的逻辑关系。本文档提供命题逻辑的完整理论框架，包括语法、语义、证明系统和应用。

Propositional logic is the foundation of formal logic, studying logical relationships between propositions. This document provides a complete theoretical framework for propositional logic, including syntax, semantics, proof systems, and applications.

## 目录 / Table of Contents

- [1. 语法 / Syntax](#1-语法--syntax)
- [2. 语义 / Semantics](#2-语义--semantics)
- [3. 证明系统 / Proof Systems](#3-证明系统--proof-systems)
- [4. 完备性 / Completeness](#4-完备性--completeness)
- [5. 应用 / Applications](#5-应用--applications)
- [代码示例 / Code Examples](#代码示例--code-examples)

---

## 1. 语法 / Syntax

### 1.1 命题变量 / Propositional Variables

**定义 1.1.1 (命题变量)**:

命题变量是表示基本命题的符号：

$$P = \{p_1, p_2, p_3, \ldots\}$$

其中每个 $p_i$ 表示一个基本命题。

### 1.2 逻辑连接词 / Logical Connectives

**定义 1.1.2 (逻辑连接词)**:

标准逻辑连接词包括：

- **否定** / **Negation**: $\neg$ (NOT)
- **合取** / **Conjunction**: $\land$ (AND)
- **析取** / **Disjunction**: $\lor$ (OR)
- **蕴含** / **Implication**: $\rightarrow$ (IF-THEN)
- **双条件** / **Biconditional**: $\leftrightarrow$ (IF-AND-ONLY-IF)

### 1.3 公式 / Formulas

**定义 1.1.3 (命题公式)**:

命题公式的递归定义：

1. 每个命题变量 $p \in P$ 是公式
2. 如果 $\phi$ 是公式，则 $\neg\phi$ 是公式
3. 如果 $\phi$ 和 $\psi$ 是公式，则 $(\phi \land \psi)$、$(\phi \lor \psi)$、$(\phi \rightarrow \psi)$、$(\phi \leftrightarrow \psi)$ 是公式

### 1.4 语法树 / Syntax Trees

**定义 1.1.4 (语法树)**:

每个公式对应一个唯一的语法树，表示公式的结构。

---

## 2. 语义 / Semantics

### 2.1 真值赋值 / Truth Assignments

**定义 2.1.1 (真值赋值)**:

真值赋值是从命题变量到真值的函数：

$$v: P \rightarrow \{T, F\}$$

### 2.2 真值表 / Truth Tables

**定义 2.1.2 (真值表)**:

真值表定义了每个连接词的真值：

| $\phi$ | $\psi$ | $\neg\phi$ | $\phi \land \psi$ | $\phi \lor \psi$ | $\phi \rightarrow \psi$ | $\phi \leftrightarrow \psi$ |
| ------ | ------ | ---------- | ----------------- | ---------------- | ----------------------- | --------------------------- |
| T      | T      | F          | T                 | T                | T                       | T                           |
| T      | F      | F          | F                 | T                | F                       | F                           |
| F      | T      | T          | F                 | T                | T                       | F                           |
| F      | F      | T          | F                 | F                | T                       | T                           |

### 2.3 满足关系 / Satisfaction Relation

**定义 2.1.3 (满足关系)**:

公式 $\phi$ 在真值赋值 $v$ 下的满足关系：

$$v \models \phi$$

递归定义：

1. $v \models p$ 当且仅当 $v(p) = T$
2. $v \models \neg\phi$ 当且仅当 $v \not\models \phi$
3. $v \models \phi \land \psi$ 当且仅当 $v \models \phi$ 且 $v \models \psi$
4. $v \models \phi \lor \psi$ 当且仅当 $v \models \phi$ 或 $v \models \psi$
5. $v \models \phi \rightarrow \psi$ 当且仅当 $v \not\models \phi$ 或 $v \models \psi$
6. $v \models \phi \leftrightarrow \psi$ 当且仅当 $v \models \phi \rightarrow \psi$ 且 $v \models \psi \rightarrow \phi$

### 2.4 重言式 / Tautologies

**定义 2.1.4 (重言式)**:

公式 $\phi$ 是重言式，当且仅当对所有真值赋值 $v$，都有 $v \models \phi$。

**定理 2.1.1 (重言式示例)**:

以下公式是重言式：

1. **排中律** / **Law of Excluded Middle**: $p \lor \neg p$
2. **矛盾律** / **Law of Contradiction**: $\neg(p \land \neg p)$
3. **德摩根律** / **De Morgan's Laws**:
   - $\neg(p \land q) \leftrightarrow (\neg p \lor \neg q)$
   - $\neg(p \lor q) \leftrightarrow (\neg p \land \neg q)$

---

## 3. 证明系统 / Proof Systems

### 3.1 自然演绎 / Natural Deduction

**定义 3.1.1 (自然演绎规则)**:

自然演绎系统包含以下规则：

**引入规则** / **Introduction Rules**:

- **合取引入** / **Conjunction Introduction**:
  $$\frac{\phi \quad \psi}{\phi \land \psi}$$
- **析取引入** / **Disjunction Introduction**:
  $$\frac{\phi}{\phi \lor \psi} \quad \frac{\psi}{\phi \lor \psi}$$
- **蕴含引入** / **Implication Introduction**:
  $$\frac{[\phi] \quad \psi}{\phi \rightarrow \psi}$$

**消去规则** / **Elimination Rules**:

- **合取消去** / **Conjunction Elimination**:
  $$\frac{\phi \land \psi}{\phi} \quad \frac{\phi \land \psi}{\psi}$$
- **析取消去** / **Disjunction Elimination**:
  $$\frac{\phi \lor \psi \quad [\phi] \quad \chi \quad [\psi] \quad \chi}{\chi}$$
- **蕴含消去** / **Implication Elimination**:
  $$\frac{\phi \rightarrow \psi \quad \phi}{\psi}$$

### 3.2 序列演算 / Sequent Calculus

**定义 3.1.2 (序列)**:

序列是形如 $\Gamma \vdash \Delta$ 的表达式，其中 $\Gamma$ 和 $\Delta$ 是公式集合。

**定义 3.1.3 (序列演算规则)**:

**结构规则** / **Structural Rules**:

- **弱化** / **Weakening**:
  $$\frac{\Gamma \vdash \Delta}{\Gamma, \phi \vdash \Delta} \quad \frac{\Gamma \vdash \Delta}{\Gamma \vdash \Delta, \phi}$$
- **收缩** / **Contraction**:
  $$\frac{\Gamma, \phi, \phi \vdash \Delta}{\Gamma, \phi \vdash \Delta} \quad \frac{\Gamma \vdash \Delta, \phi, \phi}{\Gamma \vdash \Delta, \phi}$$
- **交换** / **Exchange**:
  $$\frac{\Gamma, \phi, \psi, \Gamma' \vdash \Delta}{\Gamma, \psi, \phi, \Gamma' \vdash \Delta}$$

**逻辑规则** / **Logical Rules**:

- **否定规则** / **Negation Rules**:
  $$\frac{\Gamma \vdash \Delta, \phi}{\Gamma, \neg\phi \vdash \Delta} \quad \frac{\Gamma, \phi \vdash \Delta}{\Gamma \vdash \Delta, \neg\phi}$$
- **合取规则** / **Conjunction Rules**:
  $$\frac{\Gamma, \phi, \psi \vdash \Delta}{\Gamma, \phi \land \psi \vdash \Delta} \quad \frac{\Gamma \vdash \Delta, \phi \quad \Gamma \vdash \Delta, \psi}{\Gamma \vdash \Delta, \phi \land \psi}$$

---

## 4. 完备性 / Completeness

### 4.1 可靠性 / Soundness

**定理 4.1.1 (可靠性定理)**:

如果 $\Gamma \vdash \phi$，则 $\Gamma \models \phi$。

### 4.2 完备性 / Completeness

**定理 4.1.2 (完备性定理)**:

如果 $\Gamma \models \phi$，则 $\Gamma \vdash \phi$。

### 4.3 紧致性 / Compactness

**定理 4.1.3 (紧致性定理)**:

如果 $\Gamma \models \phi$，则存在 $\Gamma$ 的有限子集 $\Gamma'$ 使得 $\Gamma' \models \phi$。

---

## 5. 应用 / Applications

### 5.1 电路设计 / Circuit Design

命题逻辑在数字电路设计中有重要应用：

**定义 5.1.1 (逻辑门)**:

- **NOT 门**: 实现否定运算
- **AND 门**: 实现合取运算
- **OR 门**: 实现析取运算

### 5.2 程序验证 / Program Verification

**定义 5.1.2 (霍尔逻辑)**:

霍尔逻辑使用命题逻辑描述程序的前置条件和后置条件：

$$\{P\} \text{ S } \{Q\}$$

### 5.3 知识表示 / Knowledge Representation

**定义 5.1.3 (知识库)**:

知识库是命题公式的集合，用于表示领域知识。

---

## 代码示例 / Code Examples

### Rust 实现：命题逻辑解析器

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Formula {
    Variable(String),
    Not(Box<Formula>),
    And(Box<Formula>, Box<Formula>),
    Or(Box<Formula>, Box<Formula>),
    Implies(Box<Formula>, Box<Formula>),
    Biconditional(Box<Formula>, Box<Formula>),
}

#[derive(Debug, Clone)]
pub struct TruthAssignment {
    values: HashMap<String, bool>,
}

impl TruthAssignment {
    pub fn new() -> Self {
        TruthAssignment {
            values: HashMap::new(),
        }
    }

    pub fn set(&mut self, variable: String, value: bool) {
        self.values.insert(variable, value);
    }

    pub fn get(&self, variable: &str) -> bool {
        self.values.get(variable).copied().unwrap_or(false)
    }
}

impl Formula {
    pub fn evaluate(&self, assignment: &TruthAssignment) -> bool {
        match self {
            Formula::Variable(name) => assignment.get(name),
            Formula::Not(formula) => !formula.evaluate(assignment),
            Formula::And(left, right) => {
                left.evaluate(assignment) && right.evaluate(assignment)
            },
            Formula::Or(left, right) => {
                left.evaluate(assignment) || right.evaluate(assignment)
            },
            Formula::Implies(left, right) => {
                !left.evaluate(assignment) || right.evaluate(assignment)
            },
            Formula::Biconditional(left, right) => {
                left.evaluate(assignment) == right.evaluate(assignment)
            },
        }
    }

    pub fn is_tautology(&self) -> bool {
        let variables = self.get_variables();
        let mut assignment = TruthAssignment::new();
        self.check_all_assignments(&mut assignment, &variables, 0)
    }

    fn get_variables(&self) -> Vec<String> {
        let mut variables = Vec::new();
        self.collect_variables(&mut variables);
        variables.sort();
        variables.dedup();
        variables
    }

    fn collect_variables(&self, variables: &mut Vec<String>) {
        match self {
            Formula::Variable(name) => {
                if !variables.contains(name) {
                    variables.push(name.clone());
                }
            },
            Formula::Not(formula) => formula.collect_variables(variables),
            Formula::And(left, right) => {
                left.collect_variables(variables);
                right.collect_variables(variables);
            },
            Formula::Or(left, right) => {
                left.collect_variables(variables);
                right.collect_variables(variables);
            },
            Formula::Implies(left, right) => {
                left.collect_variables(variables);
                right.collect_variables(variables);
            },
            Formula::Biconditional(left, right) => {
                left.collect_variables(variables);
                right.collect_variables(variables);
            },
        }
    }

    fn check_all_assignments(
        &self,
        assignment: &mut TruthAssignment,
        variables: &[String],
        index: usize,
    ) -> bool {
        if index >= variables.len() {
            return self.evaluate(assignment);
        }

        // 尝试变量为真
        assignment.set(variables[index].clone(), true);
        if !self.check_all_assignments(assignment, variables, index + 1) {
            return false;
        }

        // 尝试变量为假
        assignment.set(variables[index].clone(), false);
        if !self.check_all_assignments(assignment, variables, index + 1) {
            return false;
        }

        true
    }
}

// 示例用法
fn main() {
    // 创建公式: (p -> q) <-> (~p v q)
    let p = Formula::Variable("p".to_string());
    let q = Formula::Variable("q".to_string());
    let not_p = Formula::Not(Box::new(p.clone()));
    let p_implies_q = Formula::Implies(Box::new(p.clone()), Box::new(q.clone()));
    let not_p_or_q = Formula::Or(Box::new(not_p), Box::new(q));
    let biconditional = Formula::Biconditional(Box::new(p_implies_q), Box::new(not_p_or_q));

    // 检查是否为重言式
    if biconditional.is_tautology() {
        println!("公式是重言式！");
    } else {
        println!("公式不是重言式。");
    }

    // 测试特定赋值
    let mut assignment = TruthAssignment::new();
    assignment.set("p".to_string(), true);
    assignment.set("q".to_string(), false);

    let result = biconditional.evaluate(&assignment);
    println!("在 p=true, q=false 下，公式的值为: {}", result);
}
```

### Haskell 实现：命题逻辑证明系统

```haskell
-- 命题逻辑公式
data Formula = Variable String
             | Not Formula
             | And Formula Formula
             | Or Formula Formula
             | Implies Formula Formula
             | Biconditional Formula Formula
             deriving (Eq, Show)

-- 真值赋值
type TruthAssignment = String -> Bool

-- 公式求值
evaluate :: Formula -> TruthAssignment -> Bool
evaluate (Variable name) assignment = assignment name
evaluate (Not formula) assignment = not (evaluate formula assignment)
evaluate (And left right) assignment =
    evaluate left assignment && evaluate right assignment
evaluate (Or left right) assignment =
    evaluate left assignment || evaluate right assignment
evaluate (Implies left right) assignment =
    not (evaluate left assignment) || evaluate right assignment
evaluate (Biconditional left right) assignment =
    evaluate left assignment == evaluate right assignment

-- 获取公式中的所有变量
getVariables :: Formula -> [String]
getVariables formula = nub $ collectVariables formula
  where
    collectVariables (Variable name) = [name]
    collectVariables (Not f) = collectVariables f
    collectVariables (And left right) = collectVariables left ++ collectVariables right
    collectVariables (Or left right) = collectVariables left ++ collectVariables right
    collectVariables (Implies left right) = collectVariables left ++ collectVariables right
    collectVariables (Biconditional left right) = collectVariables left ++ collectVariables right

-- 检查是否为重言式
isTautology :: Formula -> Bool
isTautology formula = all (evaluate formula) allAssignments
  where
    variables = getVariables formula
    allAssignments = generateAllAssignments variables

-- 生成所有可能的真值赋值
generateAllAssignments :: [String] -> [TruthAssignment]
generateAllAssignments [] = [const False]
generateAllAssignments (var:vars) =
    concatMap (\assignment ->
        [\name -> if name == var then True else assignment name,
         \name -> if name == var then False else assignment name]
    ) (generateAllAssignments vars)

-- 自然演绎证明系统
data Proof = Assumption Formula
           | NotIntro Formula Proof
           | NotElim Formula Formula Proof Proof
           | AndIntro Proof Proof
           | AndElim1 Proof
           | AndElim2 Proof
           | OrIntro1 Formula Proof
           | OrIntro2 Formula Proof
           | OrElim Proof Proof Proof
           | ImpliesIntro Formula Proof
           | ImpliesElim Proof Proof
           deriving (Show)

-- 检查证明的有效性
isValidProof :: Proof -> Bool
isValidProof (Assumption _) = True
isValidProof (NotIntro formula proof) = isValidProof proof
isValidProof (NotElim formula1 formula2 proof1 proof2) =
    isValidProof proof1 && isValidProof proof2
isValidProof (AndIntro proof1 proof2) =
    isValidProof proof1 && isValidProof proof2
isValidProof (AndElim1 proof) = isValidProof proof
isValidProof (AndElim2 proof) = isValidProof proof
isValidProof (OrIntro1 _ proof) = isValidProof proof
isValidProof (OrIntro2 _ proof) = isValidProof proof
isValidProof (OrElim proof1 proof2 proof3) =
    isValidProof proof1 && isValidProof proof2 && isValidProof proof3
isValidProof (ImpliesIntro _ proof) = isValidProof proof
isValidProof (ImpliesElim proof1 proof2) =
    isValidProof proof1 && isValidProof proof2

-- 示例：证明排中律
lawOfExcludedMiddle :: Formula -> Proof
lawOfExcludedMiddle p =
    OrIntro1 (Not p) (Assumption p)

-- 示例：证明德摩根律
deMorganLaw1 :: Formula -> Formula -> Proof
deMorganLaw1 p q =
    NotIntro (And p q)
        (AndElim1 (Assumption (And p q)))

-- 主函数
main :: IO ()
main = do
    let p = Variable "p"
    let q = Variable "q"
    let not_p = Not p
    let p_or_not_p = Or p not_p

    -- 检查排中律是否为重言式
    if isTautology p_or_not_p
        then putStrLn "排中律是重言式！"
        else putStrLn "排中律不是重言式。"

    -- 创建证明
    let proof = lawOfExcludedMiddle p
    if isValidProof proof
        then putStrLn "证明是有效的！"
        else putStrLn "证明是无效的。"
```

---

## 参考文献 / References

1. Mendelson, E. (2009). _Mathematical Logic_. Chapman and Hall/CRC.
2. van Dalen, D. (2013). _Logic and Structure_. Springer.
3. Huth, M., & Ryan, M. (2004). _Logic in Computer Science: Modelling and Reasoning about Systems_. Cambridge University Press.
4. Boolos, G., Burgess, J., & Jeffrey, R. (2007). _Computability and Logic_. Cambridge University Press.

---

_本模块为 FormalAI 提供了命题逻辑的完整理论基础，为后续的逻辑系统提供了重要的基础。_
